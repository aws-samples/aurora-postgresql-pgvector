import json
import os
import base64
from services import bedrock_agent_runtime
import streamlit as st
import uuid
from dotenv import load_dotenv

# Load environment variables and set up configurations
load_dotenv()

# Get config from environment variables
agent_id = os.environ.get('BEDROCK_AGENT_ID')
agent_alias_id = os.environ.get('BEDROCK_AGENT_ALIAS_ID')

@st.cache_data
def init_state():
    st.session_state['key'] = 'value'
    st.session_state.session_id = str(uuid.uuid4())
    st.session_state.messages = []
    st.session_state.citations = []
    st.session_state.trace = {}

# General page configuration and initialization
st.set_page_config(page_title="Agents for Amazon Bedrock - Blaize Bazaar", page_icon=":robot:", layout="wide")
st.subheader('Agents for Amazon Bedrock - Blaize Bazaar', divider='orange')
st.info("**DISCLAIMER:** This demo uses Amazon Bedrock foundation models and is not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for informational purposes only.")

logo_url = "static/Blaize.png"
st.sidebar.image(logo_url, use_container_width=True)

@st.cache_data
def get_base64_of_bin_file(bin_file):
  with open(bin_file, "rb") as f:
    data = f.read()
    return base64.b64encode(data).decode()

if "messages" not in st.session_state:
    st.session_state.messages = []

if "trace" not in st.session_state:
    st.session_state.trace = {}

if "citations" not in st.session_state:
    st.session_state.citations = []

if "session_id" not in st.session_state:
    st.session_state.session_id = "one"

# Sidebar button to reset session state
with st.sidebar:
    if st.button("Reset Session"):
        init_state()

tab1, tab2 = st.tabs(["Chat", "Architecture"])
with st.sidebar:
        st.divider()
        st.header("Sample questions")
        sample_question = st.selectbox(
            "Select a sample question or enter your own below:",
            (
                "Can you present Blaize Bazaar's product inventory in a tabular format?",
                "What's the current status of Blaize Bazaar's inventory?",
                "Our Scotch Heavy Duty Packaging (Product Id = B000087KUA) stock is getting low. What can we do about that?",
                "Can we place an order for more of our bestselling game Grand Theft Auto (Product Id = B0007TS24U)?",
                "I'm concerned about our newly listed Electronic Arcade Claw Machine (Product Id = B000KS52D2) supply. Can we address that?",
                "Can you get me pricing info on The Art of Shaving Pre Shave Beard Oil (Product Id = B000ZLZMRA)?",
                "How much would a customer pay for Taylor Battery Free Analog Scales for Body Weight (Product Id = B001FWXFNQ)?"
            ),
        )

with tab1:
    # Create a container for the chat history
    chat_container = st.container(height=800)
        
    # Create a container for the input box at the bottom
    input_container = st.container()
        
    # Use the bottom container to hold the chat input
    with input_container:
        user_question = st.chat_input('Enter your questions here...')

    # Use the sample question if the user hasn't entered anything
    if not user_question and st.sidebar.button("Try sample question"):
        user_question = sample_question

    # Initialize chat history
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []

    with chat_container:
        # Messages in the conversation
        for message in st.session_state.messages:
            with st.chat_message(message["role"]):
                st.markdown(message["content"], unsafe_allow_html=True)

        # Process the new user input
        if user_question:
            st.session_state.messages.append({"role": "user", "content": user_question})
            with st.chat_message("user"):
                st.markdown(user_question)

            with st.chat_message("assistant"):
                with st.status("Thinking...", state="running", expanded=False) as status:
                    placeholder = st.empty()
                    placeholder.markdown("...")
                    response = bedrock_agent_runtime.invoke_agent(
                        agent_id,
                        agent_alias_id,
                        st.session_state.session_id,
                        user_question
                    )
                    status.update(label="", state="complete", expanded=True)
                
                output_text = response["output_text"]

                # Add citations
                if len(response["citations"]) > 0:
                    citation_num = 1
                    num_citation_chars = 0
                    citation_locs = ""
                    for citation in response["citations"]:
                        end_span = citation["generatedResponsePart"]["textResponsePart"]["span"]["end"] + 1
                        for retrieved_ref in citation["retrievedReferences"]:
                            citation_marker = f"[{citation_num}]"
                            output_text = output_text[:end_span + num_citation_chars] + citation_marker + output_text[end_span + num_citation_chars:]
                            citation_locs = citation_locs + "\n<br>" + citation_marker + " " + retrieved_ref["location"]["s3Location"]["uri"]
                            citation_num = citation_num + 1
                            num_citation_chars = num_citation_chars + len(citation_marker)
                        output_text = output_text[:end_span + num_citation_chars] + "\n" + output_text[end_span + num_citation_chars:]
                        num_citation_chars = num_citation_chars + 1
                    output_text = output_text + "\n" + citation_locs

                placeholder.markdown(output_text, unsafe_allow_html=True)
                st.session_state.messages.append({"role": "assistant", "content": output_text})
                st.session_state.citations = response["citations"]
                st.session_state.trace = response["trace"]

                st.feedback("thumbs")

with tab2:
    st.image('static/bedrock-agent-architecture.png', use_container_width=True)

trace_type_headers = {
    "preProcessingTrace": "Pre-Processing",
    "orchestrationTrace": "Orchestration",
    "postProcessingTrace": "Post-Processing"
}
trace_info_types = ["invocationInput", "modelInvocationInput", "modelInvocationOutput", "observation", "rationale"]

# Sidebar section for trace
with st.sidebar:
    st.divider()
    st.title("Trace")

    # Show each trace types in separate sections
    step_num = 1
    for trace_type in trace_type_headers:
        st.subheader(trace_type_headers[trace_type])

        # Organize traces by step similar to how it is shown in the Bedrock console
        if trace_type in st.session_state.trace:
            trace_steps = {}
            for trace in st.session_state.trace[trace_type]:
                # Each trace type and step may have different information for the end-to-end flow
                for trace_info_type in trace_info_types:
                    if trace_info_type in trace:
                        trace_id = trace[trace_info_type]["traceId"]
                        if trace_id not in trace_steps:
                            trace_steps[trace_id] = [trace]
                        else:
                            trace_steps[trace_id].append(trace)
                        break

            # Show trace steps in JSON similar to the Bedrock console
            for trace_id in trace_steps.keys():
                with st.expander("Trace Step " + str(step_num), expanded=False):
                    for trace in trace_steps[trace_id]:
                        trace_str = json.dumps(trace, indent=2)
                        st.code(trace_str, language="json", line_numbers=trace_str.count("\n"))
                step_num = step_num + 1
        else:
            st.text("None")

    st.subheader("Citations")
    if len(st.session_state.citations) > 0:
        citation_num = 1
        for citation in st.session_state.citations:
            for retrieved_ref_num, retrieved_ref in enumerate(citation["retrievedReferences"]):
                with st.expander("Citation [" + str(citation_num) + "]", expanded=False):
                    citation_str = json.dumps({
                        "generatedResponsePart": citation["generatedResponsePart"],
                        "retrievedReference": citation["retrievedReferences"][retrieved_ref_num]
                    }, indent=2)
                    st.code(citation_str, language="json", line_numbers=trace_str.count("\n"))
                citation_num = citation_num + 1
    else:
        st.text("None")